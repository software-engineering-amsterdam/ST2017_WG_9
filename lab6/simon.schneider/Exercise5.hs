module Exercise5 where

{------------------------------------------------------------------------------
Time spent: 1h

TASK:
Use the list generated by the following function for a further test of Fermat's
primality check.

TESTS:
*Exercise5> compareTests 1 400
False positives composites 10 ( 2.5%)
False positives carmichael 400 ( 100.0%)

*Exercise5> compareTests 2 400
False positives composites 2 ( 0.5%)
False positives carmichael 399 ( 99.75%)

*Exercise5> compareTests 5 400
False positives composites 1 ( 0.25%)
False positives carmichael 400 ( 100.0%)

*Exercise5> compareTests 20 400
False positives composites 1 ( 0.25%)
False positives carmichael 399 ( 99.75%)

*Exercise5> compareTests 50 400
False positives composites 1 ( 0.25%)
False positives carmichael 395 ( 98.75%)

CONCLUSION:
According to Wikipedia the carmichael are designed to find false positives in
the fermat algoritm. They are part of the "Fermat pseudoprimes" numbers.
"A Carmichael number will pass a Fermat primality test to every base b
relatively prime to the number, even though it is not actually prime. "

As we could see in the tests almost all of the carmichael numbers were falsely
identified as primes. Even a high value of k (50) will only improve the accuracy
by less than 2%.

-------------------------------------------------------------------------------}

import Lecture6Dirty
import Exercise3

carmichael :: [Integer]
carmichael = [ (6*k+1)*(12*k+1)*(18*k+1) |
  k <- [2..],
  prime (6*k+1),
  prime (12*k+1),
  prime (18*k+1)]

findFalsePositives' :: Int -> [Integer] -> IO [Integer]
findFalsePositives' _ [] = return []
findFalsePositives' k (c:cs) =
  do
    failed <- primeTestsF k c
    if failed then
      do
        -- putStrLn ("FOUND FALSE POSITIVE: " ++ show c)
        t <- findFalsePositives' k cs
        return (c : t)
    else
      findFalsePositives' k cs

testCarMichael, testComposites :: Int -> Int -> IO [Integer]
testCarMichael k n = findFalsePositives' k (take n carmichael)
testComposites k n = findFalsePositives' k (take n composites')

compareTests :: Int -> Int -> IO ()
compareTests k n = do
  cm <- testCarMichael k n
  co <- testComposites k n
  let pcm = fromIntegral(length cm) / (fromIntegral n) * 100
  let pco = fromIntegral(length co) / (fromIntegral n) * 100
  putStrLn ("False positives composites " ++ show (length co) ++ " ( " ++ show pco ++ "%)")
  putStrLn ("False positives carmichael " ++ show (length cm) ++ " ( " ++ show pcm ++ "%)")
